import random
# import numpy as np
# import matplotlib.pyplot as plt
import discord
from discord.ext import commands
# import perlin_noise
from discord import Option
from random import *
# import sqlite3

import publicCoreData
import utils

from publicCoreData import db
from PIL import Image, ImageFilter, ImageDraw, ImageOps
import pymongo


# from main import cursor
# from main import conn

class RemoveCharView(discord.ui.View):
    def __init__(self, author,id, timeout=180):
        super().__init__(timeout=timeout)
        self.author = author
        self.id = id

    @discord.ui.button(label="–£–¥–∞–ª–∏—Ç—å", row=0, style=discord.ButtonStyle.danger,emoji="üöÆ")
    async def first_button_callback(self, button, interaction):
        db.characters.delete_one({"id": self.id})
        await interaction.response.send_message(f"–£–¥–∞–ª—ë–Ω –ø–µ—Ä—Å–æ–Ω–∞–∂ ``{self.id}``!")
        # self.disable_all_items()
        # await interaction.response.edit_message(view=self)


    @discord.ui.button(label="–û—Ç–º–µ–Ω–∞", row=0, style=discord.ButtonStyle.green, emoji="‚èπ")
    async def second_button_callback(self, button, interaction):

        await interaction.response.send_message(f"–£–¥–∞–ª–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ ``{self.id}`` –æ—Ç–º–µ–Ω–µ–Ω–æ!")
        # self.disable_all_items()
        #
        # await interaction.response.edit_message(view=self)

    async def interaction_check(self, interaction: discord.Interaction):
        return interaction.user.id == self.author.id
class RP(commands.Cog):
    result = db.countries.find({}, {"id": 1})  # –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π –∏–∑ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ "countries"
    choicesEditWPG = [str(value["id"]) for value in
                      result]  # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –≤ choices –∞—Ä–≥—É–º–µ–Ω—Ç

    def __init__(self, bot):
        self.bot = bot

    @commands.slash_command(name="–¥–≤–∞–¥—Ü–∞—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫", description="–ë—Ä–æ—Å–∏—Ç—å –¥–≤–∞–¥—Ü–∞—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫ —É–¥–∞—á–∏")
    async def dice(self, ctx, user: Option(discord.Member, description="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –æ—Ç –∏–º–µ–Ω–∏ –∫–æ—Ç–æ—Ä–æ–≥–æ –∏–¥—ë—Ç –±—Ä–æ—Å–æ–∫",
                                           required=False) = None):
        author = user if user else ctx.author
        user_data = db.users.find_one({"userid": author.id})
        if user_data:
            karma = user_data.get("karma", 0)
            luck = user_data.get("luck", 0)
        else:
            # db.users.insert_one({"userid": author.id, "karma": 0, "luck": 0})
            publicCoreData.writeUserToDB(ctx.author.id, ctx.author.name)
            karma = 0
            luck = 0

        def makeThrow():
            def genRandom():
                o = randint(1, 20) + luck
                if o > 20:
                    o = 20
                if o < 1:
                    o = 1
                return o

            out = genRandom()

            if karma < -1 and out > 10:
                out = genRandom()
            if karma > 1 and out < 10:
                out = genRandom()
            return out

        await ctx.respond(f"–ù–∞ –¥–≤–∞–¥—Ü–∞—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫–µ –≤—ã–ø–∞–ª–æ {makeThrow()}")

    @commands.slash_command(name="—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è-–≤–ø–∏", description="–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –∞–Ω–∫–µ—Ç—É –í–ü–ò")
    async def WPG_reg(self, ctx, country_name: Option(str, description="–ò–º—è —Å—Ç—Ä–∞–Ω—ã", required=True) = "Unkown",
                      government: Option(str, description="–§–æ—Ä–º–∞ –ø—Ä–∞–≤–ª–µ–Ω–∏—è", required=True) = "Unkown",
                      ideology: Option(str, description="–ò–¥–µ–æ–ª–æ–≥–∏—è", required=True) = "Unkown",
                      currency: Option(str, description="–í–∞–ª—é—Ç–∞ —Å—Ç—Ä–∞–Ω—ã. –ñ–µ–ª–∞—Ç–µ–ª—å–Ω–æ —Å —Å–∏–º–≤–æ–ª–æ–º", required=True) = "None",
                      about: Option(str, description="–û–ø–∏—Å–∞–Ω–∏–µ —Å—Ç—Ä–∞–Ω—ã", required=True) = "None",
                      flag_url: Option(str, description="URL —Ñ–ª–∞–≥–∞",
                                       required=True) = "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
                      other_symbols: Option(str, description="–ü—Ä–æ—á–∞—è —Å–∏–º–≤–æ–ª–∏–∫–∞ —Å—Ç—Ä–∞–Ω—ã", required=True) = "None",
                      ownerdata: Option(str, description="–û–ø–∏—Å–∞–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞", required=True) = "None",
                      id: Option(str, description="ID —Å—Ç—Ä–∞–Ω—ã.", required=True) = "None",
                      user: Option(discord.Member, description="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å", required=True) = None

                      ):
        with ctx.typing():
            if ctx.author.id in publicCoreData.WPG_whitelist:
                if user is None:
                    user = ctx.author
                await ctx.respond(f"–ó–∞–ø–∏—Å—å —Å—Ç—Ä–∞–Ω—ã {country_name}...")
                userid = user.id
                db.countries.insert_one({
                    "userid": userid,
                    "countryname": country_name,
                    "government": government,
                    "ideology": ideology,
                    "currency": currency,
                    "about": about,
                    "flagURL": flag_url,
                    "extraSymbols": other_symbols,
                    "ownerdata": ownerdata,
                    "id": id
                })

                await ctx.respond(f"–°—Ç—Ä–∞–Ω–∞ ``{country_name}`` –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <@{userid}> –∑–∞–ø–∏—Å–∞–Ω–∞ —Å ID ``{id}``!")
            else:
                whitelisted_user_name = " "

                await ctx.respond(
                    f"–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–∞–Ω—ã. –ü–æ–ø—Ä–æ—Å–∏—Ç–µ –∫–æ–≥–æ-–Ω–∏–±—É–¥—å –∏–∑ —Ç–µ—Ö, –∫—Ç–æ –º–æ–∂–µ—Ç —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä, <@0000000000000000000>")

    @commands.slash_command(name="—É–¥–∞–ª–µ–Ω–∏–µ-–∞–Ω–∫–µ—Ç—ã-–≤–ø–∏", description="–£–¥–∞–ª–∏—Ç—å –∞–Ω–∫–µ—Ç—É –í–ü–ò")
    async def WPG_unreg(self, ctx,
                        id: Option(str, description="ID —Å—Ç—Ä–∞–Ω—ã.", required=True) = "None",

                        ):
        with ctx.typing():
            if ctx.author.id in publicCoreData.WPG_whitelist:
                db.countries.delete_one({"id": id})
                await ctx.respond(f"–°—Ç—Ä–∞–Ω–∞ {id} —É–¥–∞–ª–µ–Ω–∞!")
            else:
                whitelisted_user_name = " "

                await ctx.respond(
                    f"–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —É–¥–∞–ª—è—Ç—å —Å—Ç—Ä–∞–Ω—ã. –ü–æ–ø—Ä–æ—Å–∏—Ç–µ –∫–æ–≥–æ-–Ω–∏–±—É–¥—å –∏–∑ —Ç–µ—Ö, –∫—Ç–æ –º–æ–∂–µ—Ç —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä, <@{random.choice(publicCoreData.WPG_whitelist)}>")

    @commands.slash_command(name="—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å-–≤–ø–∏-—Å—Ç–∞—Ç—ã", description="–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç—ã –í–ü–ò –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞")
    async def editWPGStats(self, ctx,
                           id: Option(str, description="ID –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞", choices=choicesEditWPG,
                                      required=True) = "None",
                           field: Option(str, description="–ü–æ–ª–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è", required=True, choices=[
                               "–¥–µ–Ω—å–≥–∏", "–ø–æ–ø—É–ª—è—Ü–∏—è", "—Å–æ–≥–ª–∞—Å–∏–µ –Ω–∞—Å–µ–ª–µ–Ω–∏—è", "—Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è", "–∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞", "–º–µ–¥–∏—Ü–∏–Ω–∞",
                               "–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ",
                               "–∑–∞—â–∏—Ç–∞", "–∞—Ç–∞–∫–∞", "—Ç–æ–ø–ª–∏–≤–æ", "–∫–æ—Å–º–∏—á–µ—Å–∫–æ–µ —Ç–æ–ø–ª–∏–≤–æ", "–º–µ–∂–∑–≤—ë–∑–¥–Ω–æ–µ —Ç–æ–ø–ª–∏–≤–æ",
                               "–ø—É—Å—Ç–æ—Ç–Ω–æ–µ —Ç–æ–ø–ª–∏–≤–æ", "—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç", "–∏–Ω–¥–µ–∫—Å —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π", "–µ–¥–∞", "–º–∞—Ç–µ—Ä–∏–∞–ª—ã"

                           ]) = "None",
                           value: Option(int, description="–ó–Ω–∞—á–µ–Ω–∏–µ –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ –∏–∑–º–µ–Ω–∏—Ç—å (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –¥–ª—è –≤—ã—á–∏—Ç–∞–Ω–∏—è)",
                                         required=True) = 0,
                           ephemeral: Option(bool, description="–í–∏–¥–Ω–æ –ª–∏—à—å –≤–∞–º –∏–ª–∏ –Ω–µ—Ç", required=False) = False):

        if ctx.author.id in publicCoreData.WPG_whitelist:
            with ctx.typing():
                column = ""
                if field == "–¥–µ–Ω—å–≥–∏":
                    column = "money"
                elif field == "–ø–æ–ø—É–ª—è—Ü–∏—è":
                    column = "population"
                elif field == "—Å–æ–≥–ª–∞—Å–∏–µ –Ω–∞—Å–µ–ª–µ–Ω–∏—è":
                    column = "agreement"
                elif field == "—Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è":
                    column = "area"
                elif field == "–∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞":
                    column = "infrastructure"
                elif field == "–º–µ–¥–∏—Ü–∏–Ω–∞":
                    column = "medicine"
                elif field == "–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ":
                    column = "eudication"
                elif field == "–∑–∞—â–∏—Ç–∞":
                    column = "armor"
                elif field == "–∞—Ç–∞–∫–∞":
                    column = "attack"
                elif field == "—Ç–æ–ø–ª–∏–≤–æ":
                    column = "fuel"
                elif field == "–∫–æ—Å–º–∏—á–µ—Å–∫–æ–µ —Ç–æ–ø–ª–∏–≤–æ":
                    column = "fuel_space"
                elif field == "–º–µ–∂–∑–≤—ë–∑–¥–Ω–æ–µ —Ç–æ–ø–ª–∏–≤–æ":
                    column = "fuel_star"
                elif field == "–ø—É—Å—Ç–æ—Ç–Ω–æ–µ —Ç–æ–ø–ª–∏–≤–æ":
                    column = "fuel_void"
                elif field == "—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç":
                    column = "transport"
                elif field == "–∏–Ω–¥–µ–∫—Å —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π":
                    column = "tech_index"
                elif field == "–µ–¥–∞":
                    column = "food"
                elif field == "–º–∞—Ç–µ—Ä–∏–∞–ª—ã":
                    column = "materials"
                db.countries.update_one({"id": id}, {"$inc": {column: value}})
                await ctx.respond(f"–ó–Ω–∞—á–µ–Ω–∏–µ ``{field}`` —É –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞ ``{id}`` –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ {value} –µ–¥–µ–Ω–∏—Ü(—É/—ã).",
                                  ephemeral=ephemeral)




        else:
            await ctx.respond(
                f"–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —É–¥–∞–ª—è—Ç—å —Å—Ç—Ä–∞–Ω—ã. –ü–æ–ø—Ä–æ—Å–∏—Ç–µ –∫–æ–≥–æ-–Ω–∏–±—É–¥—å –∏–∑ —Ç–µ—Ö, –∫—Ç–æ –º–æ–∂–µ—Ç —ç—Ç–æ —Å–¥–µ–ª–∞—Ç—å, –Ω–∞–ø—Ä–∏–º–µ—Ä, <@{random.choice(publicCoreData.WPG_whitelist)}>",
                ephemeral=ephemeral)

    choisesWPGButWithList = choicesEditWPG
    choisesWPGButWithList.append("list")

    @commands.slash_command(name="—Å—Ç–∞—Ç—ã-–≤–ø–∏", description="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –í–ü–ò –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞")
    async def WPG_stats(self, ctx, id: Option(str, description="ID –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞. –ù–µ –≤–≤–æ–¥–∏—Ç–µ –¥–ª—è —Å–ø–∏—Å–∫–∞",
                                              choices=choisesWPGButWithList, required=False) = "list",
                        size: Option(int, description="–ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ", required=False, choices=[1, 2, 3, 4, 5]) = 1,
                        ephemeral: Option(bool, description="–í–∏–¥–Ω–æ –ª–∏—à—å –≤–∞–º –∏–ª–∏ –Ω–µ—Ç", required=False) = False):
        with ctx.typing():

            if id == "list":
                # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                results = db.countries.find({}, {"userid": 1, "id": 1, "countryname": 1})
                out = ""
                # –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                for row in results:
                    userid = row["userid"]
                    id = row["id"]
                    countryname = row["countryname"]
                    out += f"—Å—Ç—Ä–∞–Ω–∞: **{countryname}** (ID: ``{id}``)  –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç <@{userid}> \n"
                embed = discord.Embed(title="–°—Ç—Ä–∞–Ω—ã", description="–í—Å–µ —Å—Ç—Ä–∞–Ω—ã, –∏—Ö –≤–ª–∞–¥–µ–ª—å—Ü—ã –∏ ID —Å—Ç—Ä–∞–Ω",
                                      color=discord.Color.orange())
                embed.add_field(name="–°–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞–Ω", value=f"{out}", inline=False)
                embed.set_footer(text="–î–ª—è —Å—Ç–∞—Ç–æ–≤ —Å—Ç—Ä–∞–Ω—ã –≤–≤–µ–¥–∏—Ç–µ —ç—Ç—É –∂–µ –∫–æ–º–∞–Ω–¥—É, –Ω–æ —É–∫–∞–∑–∞–≤ ID —Å—Ç—Ä–∞–Ω—ã")

                await ctx.respond(embed=embed, ephemeral=ephemeral)
            else:
                columns = 17
                imageSizeY = 200
                imageSizeX = columns * 16 + columns * 8 + 16 + 64
                image = Image.new('RGBA', (imageSizeX, imageSizeY), (0, 0, 0, 0))
                bgTileSizeX = 32
                bgTileSizeY = 32
                cell0 = Image.open("graphics/cell.png")

                backgrounds = [None, None, None, None, None]

                cells = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]
                for i in range(16):
                    cells[i] = Image.open(f"graphics/cell{i}.png")

                for i in range(5):
                    backgrounds[i] = Image.open(f"graphics/background{i + 1}.png")
                agreement = Image.open("graphics/agreement.png")
                area = Image.open("graphics/area.png")
                armor = Image.open("graphics/armor.png")
                attack = Image.open("graphics/attack.png")

                eudication = Image.open("graphics/eudication.png")
                fuel = Image.open("graphics/fuel.png")
                fuel_space = Image.open("graphics/fuel_space.png")
                fuel_star = Image.open("graphics/fuel_star.png")
                fuel_void = Image.open("graphics/fuel_void.png")
                infrastructure = Image.open("graphics/infrastructure.png")
                medicine = Image.open("graphics/medicine.png")
                money = Image.open("graphics/money.png")
                population = Image.open("graphics/population.png")
                tech = Image.open("graphics/tech.png")
                transport = Image.open("graphics/transport.png")
                materials = Image.open("graphics/materials.png")
                food = Image.open("graphics/food.png")

                result = db.countries.find_one({"id": id}, {"money": 1, "population": 1, "agreement": 1, "area": 1,
                                                            "infrastructure": 1, "medicine": 1, "eudication": 1,
                                                            "attack": 1, "armor": 1, "fuel": 1, "fuel_space": 1,
                                                            "fuel_star": 1, "fuel_void": 1, "transport": 1,
                                                            "tech_index": 1, "materials": 1, "food": 1})

                if result:
                    _money = result.get("money")
                    _population = result.get("population")
                    _agreement = result.get("agreement")
                    _area = result.get("area")
                    _infrastructure = result.get("infrastructure")
                    _medicine = result.get("medicine")
                    _eudication = result.get("eudication")
                    _attack = result.get("attack")
                    _armor = result.get("armor")
                    _fuel = result.get("fuel")
                    _fuel_space = result.get("fuel_space")
                    _fuel_star = result.get("fuel_star")
                    _fuel_void = result.get("fuel_void")
                    _transport = result.get("transport")
                    _tech_index = result.get("tech_index")
                    _materials = result.get("materials")
                    _food = result.get("food")
                arrVal = 0
                if _tech_index / 10 < 5:
                    arrVal = int(_tech_index / 10)
                else:
                    arrVal = 4
                for y in range(int(imageSizeY / bgTileSizeY)):
                    for x in range(int(imageSizeX / bgTileSizeX)):
                        image.paste(backgrounds[arrVal], (x * bgTileSizeX, y * bgTileSizeY))

                def drawBar(barIndex, barPoints, barImage):
                    layersFull = (barPoints // 10)
                    layersNotFull = barPoints % 10
                    posX = (barIndex * 16) + 16 + (8 * barIndex - 1)

                    for i in range(10):
                        image.paste(cells[layersFull], (posX, utils.invertY((i * 8) + 16, imageSizeY)))
                    for i in range(layersNotFull):
                        image.paste(cells[layersFull + 1], (posX, utils.invertY((i * 8) + 16, imageSizeY)))

                    image.paste(barImage, (posX, utils.invertY((10 * 8) + 16 + 16, imageSizeY)))

                # drawBar(1, 11, money)
                # drawBar(2, 9, money)
                drawBar(1, _money, money)
                drawBar(2, _materials, materials)
                drawBar(3, _food, food)
                drawBar(4, _population, population)
                drawBar(5, _agreement, agreement)
                drawBar(6, _area, area)
                drawBar(7, _infrastructure, infrastructure)
                drawBar(8, _medicine, medicine)
                drawBar(9, _eudication, eudication)
                drawBar(10, _attack, attack)
                drawBar(11, _armor, armor)
                drawBar(12, _fuel, fuel)
                drawBar(13, _fuel_space, fuel_space)
                drawBar(14, _fuel_star, fuel_star)
                drawBar(15, _fuel_void, fuel_void)
                drawBar(16, _transport, transport)
                drawBar(17, _tech_index, tech)

                if size > 1:
                    image = image.resize((imageSizeX * size, imageSizeY * size), resample=Image.NEAREST)
                image.save('image_buffer.png')

                modified_image_path = 'image_buffer.png'
                modified_image = discord.File(modified_image_path, filename='image_buffer.png')
                await ctx.respond(file=modified_image, ephemeral=ephemeral)
                # barPoints = 9
                # await ctx.send(f"layersFull: {(barPoints//10)}, layersNotFull: {barPoints%10} –ø—Ä–∏ barPoints: {barPoints}")
                # barPoints = 11
                # await ctx.send(
                #     f"layersFull: {(barPoints // 10)}, layersNotFull: {barPoints % 10} –ø—Ä–∏ barPoints: {barPoints}")

    @commands.slash_command(name="—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è-—Ä–ø", description="–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –†–ü –ø–µ—Ä—Å–æ–Ω–∞–∂–∞. –ú–∞–∫—Å. 2–∫ —Å–∏–º–≤–æ–ª–æ–≤/–ø–æ–ª–µ")
    async def registerChar(self, ctx, name: Option(str, description="–ò–º—è", required=True) = " ",
                           bodystats: Option(str, description="–í–µ—Å", required=True) = " ",
                           age: Option(float, description="–í–æ–∑—Ä–∞—Å—Ç (–≤ –≥–æ–¥–∞—Ö)", required=True) = 0,
                           abilities: Option(str, description="–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏", required=True) = " ",
                           weaknesses: Option(str, description="–°–ª–∞–±–æ—Å—Ç–∏", required=True) = " ",
                           character: Option(str, description="–•–∞—Ä–∞–∫—Ç–µ—Ä", required=True) = " ",
                           inventory: Option(str, description="–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å", required=True) = " ",
                           bio: Option(str, description="–ë–∏–æ–≥—Ä–∞—Ñ–∏—è. –ú–∞–∫—Å. 4–∫ —Å–∏–º–≤–æ–ª–æ–≤", required=True) = " ",
                           appearances: Option(str, description="–í–Ω–µ—à–Ω–æ—Å—Ç—å", required=True) = " ",
                           art: Option(str, description="–ê—Ä—Ç (URL)", required=False) = "https://media.discordapp.net/attachments/1018886769619505212/1176561157939662978/ad643992b38e34e2.png",
                           shortened: Option(str, description="–°–æ–∫—Ä–∞—â—ë–Ω–Ω—ã–π –ø–µ—Ä–µ—Å–∫–∞–∑", required=True) = " ",
                           id: Option(str, description="ID", required=True) = " ",
                           owner: Option(discord.Member, description="–í–ª–∞–¥–µ–ª–µ—Ü –ø–µ—Ä—Å–æ–Ω–∞–∂–∞", required=True) = 0):
        doc = {
                "name": name, "bodystats": bodystats, "age": age,
                "abilities": abilities, "weaknesses": weaknesses,
                "character": character, "inventory": inventory, "bio": bio,
                "appearances": appearances, "art": art, "shortened": shortened, "id": id,
                "owner": owner.id}
        sizeLimit = False
        oversizeKey = ""
        for k,v in doc.items():
            # if (len(str(v)) > 2000 and k!="bio") or (len(str(v)) > 4000 and k=="bio"):
            #     oversizeKey=k
            #     sizeLimit = True
            #     break
            if not "http" in art:
                oversizeKey = "–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞! –û–Ω–∞ –¥–æ–ª–∂–Ω–∞ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è –Ω–∞ http(s)://"
                sizeLimit=True
                break
        if db.characters.find_one({"id":id}):
            embed = discord.Embed(title="–ö–æ–Ω—Ñ–ª–∏–∫—Ç –∏–º—ë–Ω!",description=f"ID {id} –∑–∞–Ω—è—Ç –¥—Ä—É–≥–æ–π –∞–Ω–∫–µ—Ç–æ–π!",colour=publicCoreData.embedColors["Error"])
            await ctx.respond(embed=embed)
        else:
            if (await publicCoreData.parsePermissionFromUser(ctx.author.id, "edit_characters") or await publicCoreData.parsePermissionFromUser(ctx.author.id, "root")): #TODO: –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–æ–∏—Å–∫ –ø—Ä–∞–≤
                if not sizeLimit:
                    db.characters.insert_one(doc)
                    embed = discord.Embed(title="–ü–µ—Ä—Å–æ–Ω–∞–∂ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω!",description=f"{name} –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ ``{id}`` –∏ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç <@{owner.id}>",colour=publicCoreData.embedColors["Success"])
                    await ctx.respond(embed=embed)
                else:
                    embed = discord.Embed(title="–ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞!",description=f"–ö–ª—é—á: {oversizeKey}",colour=publicCoreData.embedColors["Error"])
                    await ctx.respond(embed=embed)
            else:
                embed = discord.Embed(title="–ù–µ—Ç –ø—Ä–∞–≤!",
                                      description="–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–∞–≤–æ ``edit_characters`` –∏–ª–∏ ``root`` –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞!",
                                      colour=publicCoreData.embedColors["Error"])
                await ctx.respond(embed=embed)
    @commands.slash_command(name="–ø–µ—Å—Ä–æ–Ω–∞–∂",description="–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –∞–Ω–∫–µ—Ç—É –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –ø–æ ID")
    async def inspectChar(self, ctx, id : Option(str, description="ID", required=True)=" ",ephemeral : Option(bool, description="–í–∏–¥–Ω–æ —Ç–æ–ª—å–∫–æ –≤–∞–º?", required=False)=False):
        result = db.characters.find_one({"id": id})
        if not result:

            await ctx.respond(f"–ü–µ—Ä—Å–æ–Ω–∞–∂ ``{id}`` –Ω–µ –Ω–∞–π–¥–µ–Ω!")
        else:
            embed = discord.Embed(title=f"–ü–µ—Ä—Å–æ–Ω–∞–∂ {result['name']}",description=f"{utils.formatStringLength(result['bio'], 4000)}",colour=publicCoreData.embedColors["Warp"])
            embed.add_field(name="–î–∞–Ω–Ω—ã–µ",value=f"–ê–≤—Ç–æ—Ä: <@{result['owner']}>\nID: ``{id}``",inline=False)
            embed.add_field(name="–†–æ—Å—Ç, –≤–µ—Å, –≤–æ–∑—Ä–∞—Å—Ç, –º–∏—Ä",value=f"{result['bodystats']}\n{result['age']} –ª–µ—Ç",inline=False)
            embed.add_field(name="–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏",value=f"{utils.formatStringLength(result['abilities'], 1024)}",inline=False)
            embed.add_field(name="–°–ª–∞–±–æ—Å—Ç–∏",value=f"{utils.formatStringLength(result['weaknesses'], 1024)}",inline=False)
            embed.add_field(name="–•–∞—Ä–∞–∫—Ç–µ—Ä",value=f"{utils.formatStringLength(result['character'], 1024)}",inline=False)
            embed.add_field(name="–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å",value=f"{utils.formatStringLength(result['inventory'], 1024)}",inline=False)
            embed.add_field(name="–í–Ω–µ—à–Ω–æ—Å—Ç—å",value=f"{utils.formatStringLength(result['appearances'],1024)}",inline=False)
            embed.add_field(name="–ö—Ä–∞—Ç–∫–∏–π –ø–µ—Ä–µ—Å–∫–∞–∑",value=f"{utils.formatStringLength(result['shortened'],1024)}",inline=False)
            embed.set_thumbnail(url=result['art'])
            await ctx.respond(embed=embed, ephemeral=ephemeral)
            #TODO: –ø–æ–∏—Å–∫ –∞–Ω–∫–µ—Ç
    @commands.slash_command(name="–ø–æ–∏—Å–∫-–ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π",description="–ò—â–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π.")
    async def searchChar(self, ctx, member : Option(discord.Member, description="–£ –∫–æ–≥–æ –∏—Å–∫–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π", required=True)=0, ephemeral : Option(bool, description="–í–∏–¥–Ω–æ –ª–∏ —Ç–æ–ª—å–∫–æ –≤–∞–º", required=False)=True):



        documents = db.characters.find({"owner": member.id}, {"name": 1, "id": 1})

        # result = []
        #
        # for doc in documents:
        #     result.append((doc["name"], doc["id"]))

        output = ""

        for doc in documents:
            output+= f"- **{doc['name']}** | **ID**: ``{doc['id']}``\n"
        if len(output) < 1:
            output = "–ù–µ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π"
        embed = discord.Embed(title="–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞",description=f"–ü–µ—Ä—Å–æ–Ω–∞–∂–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è <@{member.id}>:\n{output}",colour=publicCoreData.embedColors["Neutral"])
        await ctx.respond(embed=embed,ephemeral=ephemeral)
    @commands.slash_command(name="—É–¥–∞–ª–∏—Ç—å-–ø–µ—Ä—Å–æ–Ω–∞–∂–∞",description="–£–¥–∞–ª—è–µ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞")
    async def removeChar(self, ctx, id : Option(str, description="ID", required=True)=" "):
        if await publicCoreData.parsePermissionFromUser(ctx.author.id, "root") or await publicCoreData.parsePermissionFromUser(ctx.author.id, "edit_characters"):
            # view = RemoveCharView(ctx.author, id)  # or ctx.author/message.author where applicable
            # await ctx.response.send_message(view=view)
            db.characters.delete_one({"id": self.id})
            await ctx.respond(f"–£–¥–∞–ª—ë–Ω –ø–µ—Ä—Å–æ–Ω–∞–∂ ``{self.id}``!")
        else:
            await ctx.respond("–£ –í–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤–∞ ``root`` –∏–ª–∏ ``edit_characters`` –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π!",ephemeral=True)

